diff --git a/src/api/api_ast.cpp b/src/api/api_ast.cpp
index 1f4a86903..ce872cc5d 100644
--- a/src/api/api_ast.cpp
+++ b/src/api/api_ast.cpp
@@ -696,11 +696,45 @@ extern "C" {
     Z3_CATCH_RETURN(nullptr);
   }
 
+  static Z3_ast qf_to_simplify(Z3_context c, Z3_ast _a, Z3_params _p) {
+    Z3_TRY;
+    RESET_ERROR_CODE();
+    ast_manager & m = mk_c(c)->m();
+    expr * a = to_expr(_a);
+    params_ref p = to_param_ref(_p);
+    unsigned timeout     = p.get_uint("timeout", mk_c(c)->get_timeout());
+    bool     use_ctrl_c  = p.get_bool("ctrl_c", false);
+    th_rewriter m_rw(m, p, true);
+    expr_ref    result(m);
+    cancel_eh<reslimit> eh(m.limit());
+    api::context::set_interruptable si(*(mk_c(c)), eh);
+    {
+      scoped_ctrl_c ctrlc(eh, false, use_ctrl_c);
+      scoped_timer timer(timeout, &eh);
+      try {
+        m_rw(a, result);
+      }
+      catch (z3_exception & ex) {
+        mk_c(c)->handle_exception(ex);
+        return nullptr;
+      }
+    }
+    mk_c(c)->save_ast_trail(result);
+    return of_ast(result.get());
+    Z3_CATCH_RETURN(nullptr);
+  }
+
   Z3_ast Z3_API Z3_simplify(Z3_context c, Z3_ast _a) {
     LOG_Z3_simplify(c, _a);
     RETURN_Z3(simplify(c, _a, nullptr));
   }
 
+  Z3_ast Z3_API Z3_qf_to_simplify(Z3_context c, Z3_ast _a) {
+    LOG_Z3_simplify(c, _a);
+    RETURN_Z3(qf_to_simplify(c, _a, nullptr));
+  }
+
+
   Z3_ast Z3_API Z3_simplify_ex(Z3_context c, Z3_ast _a, Z3_params p) {
     LOG_Z3_simplify_ex(c, _a, p);
     RETURN_Z3(simplify(c, _a, p));
@@ -877,6 +911,33 @@ extern "C" {
     Z3_CATCH_RETURN("");
   }
 
+  Z3_string Z3_API Z3_benchmark_to_smtlib_string_decls_only(Z3_context c,
+      Z3_string name,
+      Z3_string logic,
+      Z3_string status,
+      Z3_string attributes,
+      unsigned num_assumptions,
+      Z3_ast const assumptions[],
+      Z3_ast formula) {
+    Z3_TRY;
+    LOG_Z3_benchmark_to_smtlib_string(c, name, logic, status, attributes, num_assumptions, assumptions, formula);
+    RESET_ERROR_CODE();
+    std::ostringstream buffer;
+    ast_smt_pp pp(mk_c(c)->m());
+    pp.set_benchmark_name(name);
+    pp.set_logic(logic?symbol(logic):symbol::null);
+    pp.set_status(status);
+    pp.add_attributes(attributes);
+    pp_params params;
+    pp.set_simplify_implies(params.simplify_implies());
+    for (unsigned i = 0; i < num_assumptions; ++i) {
+      pp.add_assumption(to_expr(assumptions[i]));
+    }
+    pp.display_smt2_decls_only(buffer, to_expr(formula));
+    return mk_c(c)->mk_external_string(buffer.str());
+    Z3_CATCH_RETURN("");
+  }
+
   Z3_decl_kind Z3_API Z3_get_decl_kind(Z3_context c, Z3_func_decl d) {
     Z3_TRY;
     LOG_Z3_get_decl_kind(c, d);
diff --git a/src/api/c++/z3++.h b/src/api/c++/z3++.h
index eef5d7904..3d654867c 100644
--- a/src/api/c++/z3++.h
+++ b/src/api/c++/z3++.h
@@ -175,11 +175,6 @@ namespace z3 {
     }
 
     void check_parser_error() const {
-            Z3_error_code e = Z3_get_error_code(*this);
-            if (e != Z3_OK && enable_exceptions()) {
-                Z3_string s = Z3_get_parser_error(*this);
-                if (s && *s) Z3_THROW(exception(s));
-            }
       check_error();
     }
 
@@ -187,7 +182,7 @@ namespace z3 {
       \brief The C++ API uses by defaults exceptions on errors. 
       For applications that don't work well with exceptions (there should be only few)
       you have the ability to turn off exceptions. The tradeoffs are that applications
-           have to be very careful about using check_error() after calls that may result in an
+      have to very careful about using check_error() after calls that may result in an
       erroneous state.
       */
     void set_enable_exceptions(bool f) { m_enable_exceptions = f; }
@@ -329,11 +324,11 @@ namespace z3 {
     /**
       \brief parsing
       */
-        expr_vector parse_string(char const* s);
-        expr_vector parse_file(char const* file);
+    expr parse_string(char const* s);
+    expr parse_file(char const* file);
 
-        expr_vector parse_string(char const* s, sort_vector const& sorts, func_decl_vector const& decls);
-        expr_vector parse_file(char const* s, sort_vector const& sorts, func_decl_vector const& decls);
+    expr parse_string(char const* s, sort_vector const& sorts, func_decl_vector const& decls);
+    expr parse_file(char const* s, sort_vector const& sorts, func_decl_vector const& decls);
 
     /**
       \brief Interpolation support
@@ -440,7 +435,6 @@ namespace z3 {
     void set(char const * k, unsigned n) { Z3_params_set_uint(ctx(), m_params, ctx().str_symbol(k), n); }
     void set(char const * k, double n) { Z3_params_set_double(ctx(), m_params, ctx().str_symbol(k), n); }
     void set(char const * k, symbol const & s) { Z3_params_set_symbol(ctx(), m_params, ctx().str_symbol(k), s); }
-        void set(char const * k, char const* s) { Z3_params_set_symbol(ctx(), m_params, ctx().str_symbol(k), ctx().str_symbol(s)); }
     friend std::ostream & operator<<(std::ostream & out, params const & p);
   };
 
@@ -486,6 +480,12 @@ namespace z3 {
       sort(context & c, Z3_sort s):ast(c, reinterpret_cast<Z3_ast>(s)) {}
       sort(sort const & s):ast(s) {}
       operator Z3_sort() const { return reinterpret_cast<Z3_sort>(m_ast); }
+
+      /**
+        \brief retrieve unique identifier for func_decl.
+        */
+      unsigned id() const { unsigned r = Z3_get_sort_id(ctx(), *this); check_error(); return r; }
+
       /**
         \brief Return true if this sort and \c s are equal.
         */
@@ -576,6 +576,11 @@ namespace z3 {
       operator Z3_func_decl() const { return reinterpret_cast<Z3_func_decl>(m_ast); }
       func_decl & operator=(func_decl const & s) { return static_cast<func_decl&>(ast::operator=(s)); }
 
+      /**
+        \brief retrieve unique identifier for func_decl.
+        */
+      unsigned id() const { unsigned r = Z3_get_func_decl_id(ctx(), *this); check_error(); return r; }
+
       unsigned arity() const { return Z3_get_arity(ctx(), *this); }
       sort domain(unsigned i) const { assert(i < arity()); Z3_sort r = Z3_get_domain(ctx(), *this, i); check_error(); return sort(ctx(), r); }
       sort range() const { Z3_sort r = Z3_get_range(ctx(), *this); check_error(); return sort(ctx(), r); }
@@ -713,6 +718,11 @@ namespace z3 {
         return std::string(Z3_get_numeral_decimal_string(ctx(), m_ast, precision));
       }
 
+      /**
+        \brief retrieve unique identifier for expression.
+        */
+      unsigned id() const { unsigned r = Z3_get_ast_id(ctx(), m_ast); check_error(); return r; }
+
       /**
         \brief Return int value of numeral, throw if result cannot fit in
         machine int
@@ -845,6 +855,7 @@ namespace z3 {
         */
       friend expr operator!(expr const & a);
 
+
       /**
         \brief Return an expression representing <tt>a and b</tt>.
 
@@ -901,16 +912,6 @@ namespace z3 {
 
       friend expr ite(expr const & c, expr const & t, expr const & e);
 
-        bool is_true() const { return is_app() && Z3_OP_TRUE == decl().decl_kind(); }
-        bool is_false() const { return is_app() && Z3_OP_FALSE == decl().decl_kind(); }
-        bool is_not() const { return is_app() && Z3_OP_NOT == decl().decl_kind(); }
-        bool is_and() const { return is_app() && Z3_OP_AND == decl().decl_kind(); }
-        bool is_or() const  { return is_app() && Z3_OP_OR  == decl().decl_kind(); }
-        bool is_xor() const { return is_app() && Z3_OP_XOR  == decl().decl_kind(); }
-        bool is_implies() const { return is_app() && Z3_OP_IMPLIES  == decl().decl_kind(); }
-        bool is_eq() const { return is_app() && Z3_OP_EQ == decl().decl_kind(); }
-        bool is_ite() const { return is_app() && Z3_OP_ITE == decl().decl_kind(); }
-        
       friend expr distinct(expr_vector const& args);
       friend expr concat(expr const& a, expr const& b);
       friend expr concat(expr_vector const& args);
@@ -1074,6 +1075,8 @@ namespace z3 {
         \brief Return a simplified version of this expression.
         */
       expr simplify() const { Z3_ast r = Z3_simplify(ctx(), m_ast); check_error(); return expr(ctx(), r); }
+
+      expr qf_to_simplify() const { Z3_ast r = Z3_qf_to_simplify(ctx(), m_ast); check_error(); return expr(ctx(), r); }
       /**
         \brief Return a simplified version of this expression. The parameter \c p is a set of parameters for the Z3 simplifier.
         */
@@ -1539,6 +1542,8 @@ namespace z3 {
       ast_vector_tpl(context & c):object(c) { init(Z3_mk_ast_vector(c)); }
       ast_vector_tpl(context & c, Z3_ast_vector v):object(c) { init(v); }
       ast_vector_tpl(ast_vector_tpl const & s):object(s), m_vector(s.m_vector) { Z3_ast_vector_inc_ref(ctx(), m_vector); }
+      ast_vector_tpl(context& c, ast_vector_tpl const& src): object(c) { init(Z3_ast_vector_translate(src.ctx(), src, c)); }
+
       ~ast_vector_tpl() { Z3_ast_vector_dec_ref(ctx(), m_vector); }
       operator Z3_ast_vector() const { return m_vector; }
       unsigned size() const { return Z3_ast_vector_size(ctx(), m_vector); }
@@ -1555,6 +1560,10 @@ namespace z3 {
         m_vector = s.m_vector;
         return *this;
       }
+      ast_vector_tpl& set(unsigned idx, ast& a) {
+        Z3_ast_vector_set(ctx(), m_vector, idx, a);
+        return *this;
+      }
       /*
          Disabled pending C++98 build upgrade
          bool contains(T const& x) const {
@@ -1568,7 +1577,7 @@ namespace z3 {
         unsigned m_index;
         public:
         iterator(ast_vector_tpl const* v, unsigned i): m_vector(v), m_index(i) {}
-            iterator(iterator& other): m_vector(other.m_vector), m_index(other.m_index) {}            
+        iterator(iterator const& other): m_vector(other.m_vector), m_index(other.m_index) {}            
         iterator operator=(iterator const& other) { m_vector = other.m_vector; m_index = other.m_index; return *this; }
 
         bool operator==(iterator const& other) {
@@ -1581,6 +1590,9 @@ namespace z3 {
           ++m_index;
           return *this;
         }
+        void set(T& arg) {
+          Z3_ast_vector_set(m_vector->ctx(), *m_vector, m_index, arg);
+        }
         iterator operator++(int) { iterator tmp = *this; ++m_index; return tmp; }
         T * operator->() const { return &(operator*()); }
         T operator*() const { return (*m_vector)[m_index]; }
@@ -2041,98 +2053,27 @@ namespace z3 {
             fml));
     }
 
-        param_descrs get_param_descrs() { return param_descrs(ctx(), Z3_solver_get_param_descrs(ctx(), m_solver)); }
-
-
-        expr_vector cube(expr_vector& vars, unsigned cutoff) { 
-            Z3_ast_vector r = Z3_solver_cube(ctx(), m_solver, vars, cutoff); 
-            check_error(); 
-            return expr_vector(ctx(), r); 
-        }  
-
-        class cube_iterator {
-            solver&      m_solver;
-            unsigned&    m_cutoff;
-            expr_vector& m_vars;
-            expr_vector  m_cube;
-            bool         m_end;
-            bool         m_empty;
-
-            void inc() {
-                assert(!m_end && !m_empty);
-                m_cube = m_solver.cube(m_vars, m_cutoff);
-                m_cutoff = 0xFFFFFFFF;
-                if (m_cube.size() == 1 && m_cube[0].is_false()) {
-                    m_cube = z3::expr_vector(m_solver.ctx());
-                    m_end = true;
-                }
-                else if (m_cube.empty()) {
-                    m_empty = true;
-                }
-            }
-        public:
-            cube_iterator(solver& s, expr_vector& vars, unsigned& cutoff, bool end):
-                m_solver(s),
-                m_cutoff(cutoff),
-                m_vars(vars),
-                m_cube(s.ctx()),
-                m_end(end),
-                m_empty(false) {
-                if (!m_end) {
-                    inc();
-                }
-            }
-
-            cube_iterator& operator++() {
-                assert(!m_end);
-                if (m_empty) {
-                    m_end = true;
+    std::string to_smt2_decls_only(char const* status = "unknown") {
+      array<Z3_ast> es(assertions());
+      Z3_ast const* fmls = es.ptr();
+      Z3_ast fml = 0;
+      unsigned sz = es.size();
+      if (sz > 0) {
+        --sz;
+        fml = fmls[sz];
       }
       else {
-                    inc();
+        fml = ctx().bool_val(true);
       }
-                return *this;
+      return std::string(Z3_benchmark_to_smtlib_string_decls_only(
+            ctx(),
+            "", "", status, "",
+            sz,
+            fmls,
+            fml));
     }
-            cube_iterator operator++(int) { assert(false); return *this; }
-            expr_vector const * operator->() const { return &(operator*()); }
-            expr_vector const& operator*() const { return m_cube; }
-            
-            bool operator==(cube_iterator const& other) {
-                return other.m_end == m_end;
-            };
-            bool operator!=(cube_iterator const& other) {
-                return other.m_end != m_end;
-            };
 
-        };
-
-        class cube_generator {
-            solver&      m_solver;
-            unsigned     m_cutoff;
-            expr_vector  m_default_vars;
-            expr_vector& m_vars;
-        public:
-            cube_generator(solver& s):
-                m_solver(s),
-                m_cutoff(0xFFFFFFFF),
-                m_default_vars(s.ctx()),
-                m_vars(m_default_vars)
-            {}
-
-            cube_generator(solver& s, expr_vector& vars):
-                m_solver(s),
-                m_cutoff(0xFFFFFFFF),
-                m_default_vars(s.ctx()),
-                m_vars(vars)
-            {}
-
-            cube_iterator begin() { return cube_iterator(m_solver, m_vars, m_cutoff, false); }
-            cube_iterator end() { return cube_iterator(m_solver, m_vars, m_cutoff, true); }
-            void set_cutoff(unsigned c) { m_cutoff = c; }
-        };
-
-        cube_generator cubes() { return cube_generator(*this); }
-        cube_generator cubes(expr_vector& vars) { return cube_generator(*this, vars); }
+    param_descrs get_param_descrs() { return param_descrs(ctx(), Z3_solver_get_param_descrs(ctx(), m_solver)); }
 
   };
   inline std::ostream & operator<<(std::ostream & out, solver const & s) { out << Z3_solver_to_string(s.ctx(), s); return out; }
@@ -2157,6 +2098,7 @@ namespace z3 {
       return *this;
     }
     void add(expr const & f) { check_context(*this, f); Z3_goal_assert(ctx(), m_goal, f); check_error(); }
+    // fails for some compilers: 
     // void add(expr_vector const& v) { check_context(*this, v); for (expr e : v) add(e); }
     unsigned size() const { return Z3_goal_size(ctx(), m_goal); }
     expr operator[](int i) const { assert(0 <= i); Z3_ast r = Z3_goal_formula(ctx(), m_goal, i); check_error(); return expr(ctx(), r); }
@@ -2167,17 +2109,6 @@ namespace z3 {
     unsigned num_exprs() const { return Z3_goal_num_exprs(ctx(), m_goal); }
     bool is_decided_sat() const { return Z3_goal_is_decided_sat(ctx(), m_goal) != 0; }
     bool is_decided_unsat() const { return Z3_goal_is_decided_unsat(ctx(), m_goal) != 0; }
-        model convert_model(model const & m) const {
-            check_context(*this, m);
-            Z3_model new_m = Z3_goal_convert_model(ctx(), m_goal, m);
-            check_error();
-            return model(ctx(), new_m);
-        }
-        model get_model() const {
-            Z3_model new_m = Z3_goal_convert_model(ctx(), m_goal, 0);
-            check_error();
-            return model(ctx(), new_m);
-        }
     expr as_expr() const {
       unsigned n = size();
       if (n == 0)
@@ -2191,7 +2122,6 @@ namespace z3 {
         return expr(ctx(), Z3_mk_and(ctx(), n, args.ptr()));
       }
     }
-        std::string dimacs() const { return std::string(Z3_goal_to_dimacs_string(ctx(), m_goal)); }
     friend std::ostream & operator<<(std::ostream & out, goal const & g);
   };
   inline std::ostream & operator<<(std::ostream & out, goal const & g) { out << Z3_goal_to_string(g.ctx(), g); return out; }
@@ -2216,6 +2146,25 @@ namespace z3 {
     }
     unsigned size() const { return Z3_apply_result_get_num_subgoals(ctx(), m_apply_result); }
     goal operator[](int i) const { assert(0 <= i); Z3_goal r = Z3_apply_result_get_subgoal(ctx(), m_apply_result, i); check_error(); return goal(ctx(), r); }
+    model convert_model(model const & m, unsigned i = 0) const {
+      check_context(*this, m);
+      Z3_model new_m = Z3_apply_result_convert_model(ctx(), m_apply_result, i, m);
+      check_error();
+      return model(ctx(), new_m);
+    }
+    expr as_expr() const {
+      unsigned n = size();
+      if (n == 0)
+        return ctx().bool_val(true);
+      else if (n == 1)
+        return operator[](0).as_expr();
+      else {
+        array<Z3_ast> args(n);
+        for (unsigned i = 0; i < n; i++)
+          args[i] = operator[](i).as_expr();
+        return expr(ctx(), Z3_mk_or(ctx(), n, args.ptr()));
+      }
+    }
     friend std::ostream & operator<<(std::ostream & out, apply_result const & r);
   };
   inline std::ostream & operator<<(std::ostream & out, apply_result const & r) { out << Z3_apply_result_to_string(r.ctx(), r); return out; }
@@ -2973,19 +2922,18 @@ namespace z3 {
     return expr(a.ctx(), Z3_mk_interpolant(a.ctx(), a));
   }
 
-    inline expr_vector context::parse_string(char const* s) {
-        Z3_ast_vector r = Z3_parse_smtlib2_string(*this, s, 0, 0, 0, 0, 0, 0);
-        check_error();
-        return expr_vector(*this, r);
-        
+  inline expr context::parse_string(char const* s) {
+    Z3_ast r = Z3_parse_smtlib2_string(*this, s, 0, 0, 0, 0, 0, 0);
+    check_parser_error();
+    return expr(*this, r);        
   }
-    inline expr_vector context::parse_file(char const* s) {
-        Z3_ast_vector r = Z3_parse_smtlib2_file(*this, s, 0, 0, 0, 0, 0, 0);
-        check_error();
-        return expr_vector(*this, r);
+  inline expr context::parse_file(char const* s) {
+    Z3_ast r = Z3_parse_smtlib2_file(*this, s, 0, 0, 0, 0, 0, 0);
+    check_parser_error();
+    return expr(*this, r);
   }
 
-    inline expr_vector context::parse_string(char const* s, sort_vector const& sorts, func_decl_vector const& decls) {
+  inline expr context::parse_string(char const* s, sort_vector const& sorts, func_decl_vector const& decls) {
     array<Z3_symbol> sort_names(sorts.size());
     array<Z3_symbol> decl_names(decls.size());
     array<Z3_sort>   sorts1(sorts);
@@ -2996,13 +2944,12 @@ namespace z3 {
     for (unsigned i = 0; i < decls.size(); ++i) {
       decl_names[i] = decls[i].name();
     }
-
-        Z3_ast_vector r = Z3_parse_smtlib2_string(*this, s, sorts.size(), sort_names.ptr(), sorts1.ptr(), decls.size(), decl_names.ptr(), decls1.ptr());
-        check_error();
-        return expr_vector(*this, r);
+    Z3_ast r = Z3_parse_smtlib2_string(*this, s, sorts.size(), sort_names.ptr(), sorts1.ptr(), decls.size(), decl_names.ptr(), decls1.ptr());
+    check_parser_error();
+    return expr(*this, r);
   }
 
-    inline expr_vector context::parse_file(char const* s, sort_vector const& sorts, func_decl_vector const& decls) {
+  inline expr context::parse_file(char const* s, sort_vector const& sorts, func_decl_vector const& decls) {
     array<Z3_symbol> sort_names(sorts.size());
     array<Z3_symbol> decl_names(decls.size());
     array<Z3_sort>   sorts1(sorts);
@@ -3013,9 +2960,9 @@ namespace z3 {
     for (unsigned i = 0; i < decls.size(); ++i) {
       decl_names[i] = decls[i].name();
     }
-        Z3_ast_vector r = Z3_parse_smtlib2_file(*this, s, sorts.size(), sort_names.ptr(), sorts1.ptr(), decls.size(), decl_names.ptr(), decls1.ptr());
-        check_error();
-        return expr_vector(*this, r);
+    Z3_ast r = Z3_parse_smtlib2_file(*this, s, sorts.size(), sort_names.ptr(), sorts1.ptr(), decls.size(), decl_names.ptr(), decls1.ptr());
+    check_parser_error();
+    return expr(*this, r);
   }
diff --git a/src/api/z3_api.h b/src/api/z3_api.h
index d5c279d63..c2b2596a2 100644
--- a/src/api/z3_api.h
+++ b/src/api/z3_api.h
@@ -83,14 +83,14 @@ typedef const char * Z3_string;
 typedef Z3_string * Z3_string_ptr;
 
 /**
-   \brief True value. It is just an alias for \c true.
+  \brief True value. It is just an alias for \c 1.
   */
-#define Z3_TRUE  true
+#define Z3_TRUE  1
 
 /**
-   \brief False value. It is just an alias for \c false.
+  \brief False value. It is just an alias for \c 0.
   */
-#define Z3_FALSE false
+#define Z3_FALSE 0
 
 /**
   \brief Lifted Boolean type: \c false, \c undefined, \c true.
@@ -4633,6 +4633,16 @@ extern "C" {
     */
   Z3_ast Z3_API Z3_simplify(Z3_context c, Z3_ast a);
 
+  /** 
+    \brief Interface to QF_TO simplifier
+
+    Provides an interface to the AST simplifier for quantifier
+    free term in the language of total order.
+    It returns an AST object which is equal to the argument.
+    The returned AST is simplified using algebraic simplification rules,
+    */
+  Z3_ast Z3_API Z3_qf_to_simplify(Z3_context c, Z3_ast a);
+
   /**
     \brief Interface to simplifier.
 
@@ -5164,6 +5174,33 @@ extern "C" {
       unsigned num_assumptions,
       Z3_ast const assumptions[],
       Z3_ast formula);
+  /**
+    \brief Convert the given benchmark into SMT-LIB formatted string. * Declarations only. *
+
+    \warning The result buffer is statically allocated by Z3. It will
+    be automatically deallocated when #Z3_del_context is invoked.
+    So, the buffer is invalidated in the next call to \c Z3_benchmark_to_smtlib_string.
+
+    \param c - context.
+    \param name - name of benchmark. The argument is optional.
+    \param logic - the benchmark logic.
+    \param status - the status string (sat, unsat, or unknown)
+    \param attributes - other attributes, such as source, difficulty or category.
+    \param num_assumptions - number of assumptions.
+    \param assumptions - auxiliary assumptions.
+    \param formula - formula to be checked for consistency in conjunction with assumptions.
+
+    def_API('Z3_benchmark_to_smtlib_string_decls_only', STRING, (_in(CONTEXT), _in(STRING), _in(STRING), _in(STRING), _in(STRING), _in(UINT), _in_array(5, AST), _in(AST)))
+    */
+  Z3_string Z3_API Z3_benchmark_to_smtlib_string_decls_only(Z3_context c,
+      Z3_string name,
+      Z3_string logic,
+      Z3_string status,
+      Z3_string attributes,
+      unsigned num_assumptions,
+      Z3_ast const assumptions[],
+      Z3_ast formula);
+
 
   /*@}*/
 
@@ -5175,9 +5212,9 @@ extern "C" {
     It returns a formula comprising of the conjunction of assertions in the scope
     (up to push/pop) at the end of the string.
 
-       def_API('Z3_parse_smtlib2_string', AST_VECTOR, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _in(UINT), _in_array(5, SYMBOL), _in_array(5, FUNC_DECL)))
+    def_API('Z3_parse_smtlib2_string', AST, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _in(UINT), _in_array(5, SYMBOL), _in_array(5, FUNC_DECL)))
     */
-    Z3_ast_vector Z3_API Z3_parse_smtlib2_string(Z3_context c,
+  Z3_ast Z3_API Z3_parse_smtlib2_string(Z3_context c,
       Z3_string str,
       unsigned num_sorts,
       Z3_symbol const sort_names[],
@@ -5189,9 +5226,9 @@ extern "C" {
   /**
     \brief Similar to #Z3_parse_smtlib2_string, but reads the benchmark from a file.
 
-       def_API('Z3_parse_smtlib2_file', AST_VECTOR, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _in(UINT), _in_array(5, SYMBOL), _in_array(5, FUNC_DECL)))
+    def_API('Z3_parse_smtlib2_file', AST, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _in(UINT), _in_array(5, SYMBOL), _in_array(5, FUNC_DECL)))
     */
-    Z3_ast_vector Z3_API Z3_parse_smtlib2_file(Z3_context c,
+  Z3_ast Z3_API Z3_parse_smtlib2_file(Z3_context c,
       Z3_string file_name,
       unsigned num_sorts,
       Z3_symbol const sort_names[],
@@ -5450,15 +5487,6 @@ extern "C" {
     */
   Z3_goal Z3_API Z3_goal_translate(Z3_context source, Z3_goal g, Z3_context target);
 
-    /**
-       \brief Convert a model of the formulas of a goal to a model of an original goal.
-       The model may be null, in which case the returned model is valid if the goal was
-       established satisfiable.
-
-       def_API('Z3_goal_convert_model', MODEL, (_in(CONTEXT), _in(GOAL), _in(MODEL)))
-    */
-    Z3_model Z3_API Z3_goal_convert_model(Z3_context c, Z3_goal g, Z3_model m);
-
   /**
     \brief Convert a goal into a string.
 
@@ -5466,13 +5494,6 @@ extern "C" {
     */
   Z3_string Z3_API Z3_goal_to_string(Z3_context c, Z3_goal g);
 
-    /**
-       \brief Convert a goal into a DIMACS formatted string.
-
-       def_API('Z3_goal_to_dimacs_string', STRING, (_in(CONTEXT), _in(GOAL)))
-    */
-    Z3_string Z3_API Z3_goal_to_dimacs_string(Z3_context c, Z3_goal g);
-
   /*@}*/
 
   /** @name Tactics and Probes */
@@ -5825,6 +5846,14 @@ extern "C" {
     */
   Z3_goal Z3_API Z3_apply_result_get_subgoal(Z3_context c, Z3_apply_result r, unsigned i);
 
+  /**
+    \brief Convert a model for the subgoal \c Z3_apply_result_get_subgoal(c, r, i) into a model for the original goal \c g.
+    Where \c g is the goal used to create \c r using \c Z3_tactic_apply(c, t, g).
+
+    def_API('Z3_apply_result_convert_model', MODEL, (_in(CONTEXT), _in(APPLY_RESULT), _in(UINT), _in(MODEL)))
+    */
+  Z3_model Z3_API Z3_apply_result_convert_model(Z3_context c, Z3_apply_result r, unsigned i, Z3_model m);
+
   /*@}*/
 
   /** @name Solvers*/
@@ -5924,13 +5953,6 @@ extern "C" {
     */
   Z3_solver Z3_API Z3_solver_translate(Z3_context source, Z3_solver s, Z3_context target);
 
-    /**
-       \brief Ad-hoc method for importing model convertion from solver.
-       
-       def_API('Z3_solver_import_model_converter', VOID, (_in(CONTEXT), _in(SOLVER), _in(SOLVER)))
-     */
-    void Z3_API Z3_solver_import_model_converter(Z3_context ctx, Z3_solver src, Z3_solver dst);
-
   /**
     \brief Return a string describing all solver available parameters.
 
@@ -6031,6 +6053,13 @@ extern "C" {
     */
   void Z3_API Z3_solver_assert_and_track(Z3_context c, Z3_solver s, Z3_ast a, Z3_ast p);
 
+  /**
+    \brief Return the set of asserted formulas on the solver.
+
+    def_API('Z3_solver_get_assertions', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
+    */
+  Z3_ast_vector Z3_API Z3_solver_get_assertions(Z3_context c, Z3_solver s);
+
   /**
     \brief load solver assertions from a file.
 
@@ -6045,20 +6074,6 @@ extern "C" {
     */
   void Z3_API Z3_solver_from_string(Z3_context c, Z3_solver s, Z3_string file_name);
 
-    /**
-       \brief Return the set of asserted formulas on the solver.
-
-       def_API('Z3_solver_get_assertions', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
-    */
-    Z3_ast_vector Z3_API Z3_solver_get_assertions(Z3_context c, Z3_solver s);
-
-    /**
-       \brief Return the set of units modulo model conversion.
-
-       def_API('Z3_solver_get_units', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
-    */
-    Z3_ast_vector Z3_API Z3_solver_get_units(Z3_context c, Z3_solver s);
-
   /**
     \brief Check whether the assertions in a given solver are consistent or not.
 
@@ -6126,28 +6141,6 @@ extern "C" {
       Z3_ast_vector assumptions,
       Z3_ast_vector variables,
       Z3_ast_vector consequences);
-
-
-    /**
-       \brief extract a next cube for a solver. The last cube is the constant \c true or \c false.
-       The number of (non-constant) cubes is by default 1. For the sat solver cubing is controlled
-       using parameters sat.lookahead.cube.cutoff and sat.lookahead.cube.fraction.
-       
-       The third argument is a vector of variables that may be used for cubing.
-       The contents of the vector is only used in the first call. The initial list of variables
-       is used in subsequent calls until it returns the unsatisfiable cube. 
-       The vector is modified to contain a set of Autarky variables that occor in clauses that
-       are affected by the (last literal in the) cube. These variables could be used by a different
-       cuber (on a different solver object) for further recursive cubing. 
-
-       The last argument is a backtracking level. It instructs the cube process to backtrack below
-       the indicated level for the next cube.
-       
-       def_API('Z3_solver_cube', AST_VECTOR, (_in(CONTEXT), _in(SOLVER), _in(AST_VECTOR), _in(UINT)))
-    */
-
-    Z3_ast_vector Z3_API Z3_solver_cube(Z3_context c, Z3_solver s, Z3_ast_vector vars, unsigned backtrack_level);
-
   /**
     \brief Retrieve the model for the last #Z3_solver_check or #Z3_solver_check_assumptions
diff --git a/src/ast/rewriter/arith_rewriter.cpp b/src/ast/rewriter/arith_rewriter.cpp
index 9824884a4..fae7b4b89 100644
--- a/src/ast/rewriter/arith_rewriter.cpp
+++ b/src/ast/rewriter/arith_rewriter.cpp
@@ -800,54 +800,9 @@ br_status arith_rewriter::mk_idiv_core(expr * arg1, expr * arg2, expr_ref & resu
     result = m_util.mk_numeral(div(v1, v2), is_int);
     return BR_DONE;
   }
-    expr_ref quot(m());
-    if (divides(arg1, arg2, quot)) {
-        result = m_util.mk_mul(quot, m_util.mk_idiv(arg1, arg1));
-        return BR_REWRITE2;
-    }
   return BR_FAILED;
 }
 
-bool arith_rewriter::divides(expr* d, expr* n, expr_ref& quot) {
-    if (d == n) {
-        quot = m_util.mk_numeral(rational(1), m_util.is_int(d));
-        return true;
-    }
-    if (m_util.is_mul(n)) {
-        expr_ref_vector muls(m());
-        muls.push_back(n);
-        expr* n1, *n2;
-        rational r1, r2;
-        for (unsigned i = 0; i < muls.size(); ++i) {
-            if (m_util.is_mul(muls[i].get(), n1, n2)) {
-                muls[i] = n1;
-                muls.push_back(n2);
-                --i;
-            }
-        }
-        if (m_util.is_numeral(d, r1) && !r1.is_zero()) {
-            for (unsigned i = 0; i < muls.size(); ++i) {
-                if (m_util.is_numeral(muls[i].get(), r2) && (r2 / r1).is_int()) {
-                    muls[i] = m_util.mk_numeral(r2 / r1, m_util.is_int(d));
-                    quot = m_util.mk_mul(muls.size(), muls.c_ptr());
-                    return true;
-                }            
-            }
-        }
-        else {
-            for (unsigned i = 0; i < muls.size(); ++i) {
-                if (d == muls[i].get()) {
-                    muls[i] = muls.back();
-                    muls.pop_back();
-                    quot = m_util.mk_mul(muls.size(), muls.c_ptr());
-                    return true;
-                }            
-            }
-        }
-    }
-    return false;
-}
-
 br_status arith_rewriter::mk_mod_core(expr * arg1, expr * arg2, expr_ref & result) {
   set_curr_sort(m().get_sort(arg1));
   numeral v1, v2;
@@ -1700,3 +1655,209 @@ br_status arith_rewriter::mk_tanh_core(expr * arg, expr_ref & result) {
 }
 
 template class poly_rewriter<arith_rewriter_core>;
+
+br_status qf_to_rewriter::mk_app_core(func_decl * f, unsigned num_args, expr * const * args, expr_ref & result) {
+  br_status st = BR_FAILED;
+  SASSERT(f->get_family_id() == get_fid());
+  switch (f->get_decl_kind()) {
+    case OP_NUM: st = BR_FAILED; break;
+    case OP_IRRATIONAL_ALGEBRAIC_NUM: st = BR_FAILED; break;
+    case OP_LE:  SASSERT(num_args == 2); st = mk_le_core(args[0], args[1], result); break;
+    case OP_GE:  SASSERT(num_args == 2); st = mk_ge_core(args[0], args[1], result); break;
+    case OP_LT:  SASSERT(num_args == 2); st = mk_lt_core(args[0], args[1], result); break;
+    case OP_GT:  SASSERT(num_args == 2); st = mk_gt_core(args[0], args[1], result); break;
+    case OP_ADD: st = mk_add_core(num_args, args, result); break;
+    case OP_MUL: st = mk_mul_core(num_args, args, result); break;
+    case OP_SUB: st = mk_sub(num_args, args, result); break;
+    case OP_DIV: if (num_args == 1) { result = args[0]; st = BR_DONE; break; }
+                   SASSERT(num_args == 2); st = mk_div_core(args[0], args[1], result); break;
+    case OP_IDIV: if (num_args == 1) { result = args[0]; st = BR_DONE; break; }
+                    SASSERT(num_args == 2); st = mk_idiv_core(args[0], args[1], result); break;
+    case OP_MOD: SASSERT(num_args == 2); st = mk_mod_core(args[0], args[1], result); break;
+    case OP_REM: SASSERT(num_args == 2); st = mk_rem_core(args[0], args[1], result); break;
+    case OP_UMINUS: SASSERT(num_args == 1);  st = mk_uminus(args[0], result); break;
+    case OP_TO_REAL: SASSERT(num_args == 1); st = mk_to_real_core(args[0], result); break;
+    case OP_TO_INT: SASSERT(num_args == 1);  st = mk_to_int_core(args[0], result); break;
+    case OP_IS_INT: SASSERT(num_args == 1);  st = mk_is_int(args[0], result); break;
+    case OP_POWER:  SASSERT(num_args == 2);  st = mk_power_core(args[0], args[1], result); break;
+    case OP_ABS:    SASSERT(num_args == 1);  st = mk_abs_core(args[0], result); break;
+    case OP_SIN: SASSERT(num_args == 1); st = mk_sin_core(args[0], result); break;
+    case OP_COS: SASSERT(num_args == 1); st = mk_cos_core(args[0], result); break;
+    case OP_TAN: SASSERT(num_args == 1); st = mk_tan_core(args[0], result); break;
+    case OP_ASIN: SASSERT(num_args == 1); st = mk_asin_core(args[0], result); break;
+    case OP_ACOS: SASSERT(num_args == 1); st = mk_acos_core(args[0], result); break;
+    case OP_ATAN: SASSERT(num_args == 1); st = mk_atan_core(args[0], result); break;
+    case OP_SINH: SASSERT(num_args == 1); st = mk_sinh_core(args[0], result); break;
+    case OP_COSH: SASSERT(num_args == 1); st = mk_cosh_core(args[0], result); break;
+    case OP_TANH: SASSERT(num_args == 1); st = mk_tanh_core(args[0], result); break;
+    default: st = BR_FAILED; break;
+  }
+  CTRACE("arith_rewriter", st != BR_FAILED, tout << mk_pp(f, m());
+      for (unsigned i = 0; i < num_args; ++i) tout << mk_pp(args[i], m()) << " ";
+      tout << "\n==>\n" << mk_pp(result.get(), m()) << "\n";);
+  return st;
+}
+
+br_status qf_to_rewriter::qf_to_normalizer(expr * arg1, expr * arg2, 
+    QF_TO_OP kind, expr_ref & result, 
+    expr_ref & _new_arg_1, expr_ref & _new_arg_2,
+    bool & is_c_at_rhs) {
+  expr *orig_arg1 = arg1, *orig_arg2 = arg2;
+  expr_ref new_arg1(m());
+  expr_ref new_arg2(m());
+  br_status st = only_non_neg_monomials(arg1, arg2, new_arg1, new_arg2, is_c_at_rhs);
+  TRACE("mk_le_bug", tout << "st: " << st << " " << new_arg1 << " " << new_arg2 << "\n";);
+  if (st != BR_FAILED) {
+    arg1 = new_arg1;
+    arg2 = new_arg2;
+  }
+  
+  numeral a1, a2;
+  if (is_numeral(arg1, a1) && is_numeral(arg2, a2)) {
+    switch (kind) {
+      case LE: result = a1 <= a2 ? m().mk_true() : m().mk_false(); return BR_DONE;
+      case LT: result = a1 < a2  ? m().mk_true() : m().mk_false(); return BR_DONE;
+      default: result = a1 == a2 ? m().mk_true() : m().mk_false(); return BR_DONE;
+    }
+  }
+
+  if (st == BR_DONE && arg1 == orig_arg1 && arg2 == orig_arg2) {
+    // Nothing new; return BR_FAILED to avoid rewriting loops.
+    _new_arg_1 = arg1;
+    _new_arg_2 = arg2;
+    return BR_FAILED;
+  }
+  else if (st != BR_FAILED) {
+    switch (kind) {
+      case LE: _new_arg_1 = arg1; _new_arg_2 = arg2; result = m_util.mk_le(arg1, arg2); return BR_DONE;
+      case LT: _new_arg_1 = arg1; _new_arg_2 = arg2; result = m_util.mk_lt(arg1, arg2); return BR_DONE;
+      default: _new_arg_1 = arg1; _new_arg_2 = arg2; result = m().mk_eq(arg1, arg2);    return BR_DONE;
+    }
+  }
+
+  return BR_FAILED;
+}
+
+br_status qf_to_rewriter::mk_le_core(expr * arg1, expr * arg2, expr_ref & result) {
+  expr *orig_arg1 = arg1, *orig_arg2 = arg2;
+  bool is_c_at_rhs = false;
+  expr_ref new_arg1(m());
+  expr_ref new_arg2(m());
+  br_status ans = qf_to_normalizer(arg1, arg2, LE, result, 
+      new_arg1, new_arg2, is_c_at_rhs);
+  // qf_to relaxation
+  // Relax the expression if either:
+  // 1. The expression didnt change but qf_to_normalizer returned BR_FAILED
+  // 2. qf_to_normalizer didnt return BR_FAILED and is not
+  // a primitive boolean value nor the numeral positive value
+  // appears on the right hand side
+  if((ans == BR_FAILED && arg1 == new_arg1 && arg2 == new_arg2) 
+      || (ans != BR_FAILED 
+        && !(m().is_false(result) || m().is_true(result)) 
+        && !is_c_at_rhs)){
+    expr * _arg1 = new_arg1;
+    expr * _arg2 = new_arg2;
+    unsigned lhs_sz;
+    expr * const * lhs_monomials = get_monomials(_arg1, lhs_sz);
+    unsigned rhs_sz;
+    expr * const * rhs_monomials = get_monomials(_arg2, rhs_sz);
+
+    if(lhs_sz > 2 || rhs_sz > 1){
+      // BR_FAILED is returned because
+      // 'result' IS NOT in QF_TO
+      return BR_FAILED;
+    }
+
+    switch(lhs_sz){
+      case 1:
+        if(is_numeral(_arg1)){
+          if(!is_zero(_arg1)){
+            result = m_util.mk_lt(m_util.mk_numeral(numeral(0), true), _arg2);
+            return BR_DONE;
+          }
+        }
+        if(orig_arg1 == _arg1 && orig_arg2 == _arg2)
+          return BR_FAILED;
+        return BR_DONE;
+      case 2:
+        {
+          expr * lhs_monomial = 
+            is_numeral(lhs_monomials[0]) ? lhs_monomials[1] : lhs_monomials[0];
+          result = m_util.mk_lt(lhs_monomial, _arg2);
+          return BR_DONE;
+        }
+      case 0:
+      default:
+        return BR_FAILED;
+    }
+  }
+
+  return ans;
+}
+
+br_status qf_to_rewriter::mk_lt_core(expr * arg1, expr * arg2, expr_ref & result) {
+  expr *orig_arg1 = arg1, *orig_arg2 = arg2;
+  bool is_c_at_rhs = false;
+  expr_ref new_arg1(m());
+  expr_ref new_arg2(m());
+  br_status ans = qf_to_normalizer(arg1, arg2, LT, result, 
+      new_arg1, new_arg2, is_c_at_rhs);
+  // qf_to relaxation
+  // Relax the expression if either:
+  // 1. The expression didnt change but qf_to_normalizer returned BR_FAILED
+  // 2. qf_to_normalizer didnt return BR_FAILED and is not
+  // a primitive boolean value nor the numeral positive value
+  // appears on the right hand side
+  if((ans == BR_FAILED && arg1 == new_arg1 && arg2 == new_arg2) 
+      || (ans != BR_FAILED 
+        && !(m().is_false(result) || m().is_true(result)) 
+        && !is_c_at_rhs)){
+    expr * _arg1 = new_arg1;
+    expr * _arg2 = new_arg2;
+    unsigned lhs_sz;
+    expr * const * lhs_monomials = get_monomials(_arg1, lhs_sz);
+    unsigned rhs_sz;
+    expr * const * rhs_monomials = get_monomials(_arg2, rhs_sz);
+
+    if(lhs_sz > 2 || rhs_sz > 1){
+      // BR_FAILED is returned because
+      // 'result' IS NOT in QF_TO
+      return BR_FAILED;
+    }
+
+    switch(lhs_sz){
+      case 1:
+        if(is_numeral(_arg1)){
+          result = m_util.mk_lt(m_util.mk_numeral(numeral(0), true), _arg2);
+          if(is_zero(orig_arg1) && orig_arg2 == _arg2)
+            return BR_FAILED;
+          return BR_DONE;
+        }
+        if(orig_arg1 == _arg1 && orig_arg2 == _arg2)
+          return BR_FAILED;
+        return BR_DONE;
+      case 2:
+        {
+          expr * lhs_monomial = 
+            is_numeral(lhs_monomials[0]) ? lhs_monomials[1] : lhs_monomials[0];
+          result = m_util.mk_lt(lhs_monomial, _arg2);
+          if(orig_arg1 == lhs_monomial && orig_arg2 == _arg2)
+            return BR_FAILED;
+          return BR_DONE;
+        }
+      case 0:
+      default:
+        return BR_FAILED;
+    }
+  }
+
+  return ans;
+}
+
+br_status qf_to_rewriter::mk_ge_core(expr * arg1, expr * arg2, expr_ref & result) {
+  return mk_le_core(arg2, arg1, result);
+}
+
+br_status qf_to_rewriter::mk_gt_core(expr * arg1, expr * arg2, expr_ref & result) {
+  return mk_lt_core(arg2, arg1, result);
+}
diff --git a/src/ast/rewriter/arith_rewriter.h b/src/ast/rewriter/arith_rewriter.h
index 65fbfb43f..e74468374 100644
--- a/src/ast/rewriter/arith_rewriter.h
+++ b/src/ast/rewriter/arith_rewriter.h
@@ -1,6 +1,5 @@
 /*++
   Copyright (c) 2011 Microsoft Corporation 
-
   Module Name:
 
   arith_rewriter.h
@@ -48,6 +47,8 @@ public:
 };
 
 class arith_rewriter : public poly_rewriter<arith_rewriter_core> {
+  friend class qf_to_rewriter;
+
   bool m_arith_lhs;
   bool m_arith_ineq_lhs;
   bool m_gcd_rounding;
@@ -95,7 +96,6 @@ class arith_rewriter : public poly_rewriter<arith_rewriter_core> {
   expr_ref neg_monomial(expr * e) const;
   expr * mk_sin_value(rational const & k);
   app * mk_sqrt(rational const & k);
-    bool divides(expr* d, expr* n, expr_ref& quot);
 
   public:
   arith_rewriter(ast_manager & m, params_ref const & p = params_ref()):
@@ -186,4 +186,22 @@ public:
   br_status mk_tanh_core(expr * arg, expr_ref & result);
 };
 
+class qf_to_rewriter : public arith_rewriter {
+
+  enum QF_TO_OP { LE, LT };
+  br_status qf_to_normalizer(expr * arg1, expr * arg2, QF_TO_OP kind, 
+      expr_ref & result, expr_ref & new_arg1, expr_ref & new_arg2, bool &);
+
+  public:
+  qf_to_rewriter(ast_manager & m, params_ref const & p = params_ref()):
+    arith_rewriter(m, p) { }
+
+  br_status mk_app_core(func_decl * f, unsigned num_args, expr * const * args, expr_ref & result);
+
+  br_status mk_le_core(expr * arg1, expr * arg2, expr_ref & result);
+  br_status mk_lt_core(expr * arg1, expr * arg2, expr_ref & result);
+  br_status mk_ge_core(expr * arg1, expr * arg2, expr_ref & result);
+  br_status mk_gt_core(expr * arg1, expr * arg2, expr_ref & result);
+};
+
 #endif
diff --git a/src/ast/rewriter/th_rewriter.cpp b/src/ast/rewriter/th_rewriter.cpp
index f5a0ff0f7..4478b0cd5 100644
--- a/src/ast/rewriter/th_rewriter.cpp
+++ b/src/ast/rewriter/th_rewriter.cpp
@@ -38,6 +38,7 @@ Notes:
 struct th_rewriter_cfg : public default_rewriter_cfg {
   bool_rewriter       m_b_rw;
   arith_rewriter      m_a_rw;
+  qf_to_rewriter      m_qf_to_rw;
   bv_rewriter         m_bv_rw;
   array_rewriter      m_ar_rw;
   datatype_rewriter   m_dt_rw;
@@ -56,6 +57,7 @@ struct th_rewriter_cfg : public default_rewriter_cfg {
   bool                m_push_ite_bv;
   bool                m_ignore_patterns_on_ground_qbody;
   bool                m_rewrite_patterns;
+  bool                m_is_qf_to;
 
   // substitution support
   expr_dependency_ref m_used_dependencies; // set of dependencies of used substitutions
@@ -171,8 +173,12 @@ struct th_rewriter_cfg : public default_rewriter_cfg {
         // theory dispatch for =
         SASSERT(num == 2);
         family_id s_fid = m().get_sort(args[0])->get_family_id();
-                if (s_fid == m_a_rw.get_fid())
+        if (s_fid == m_a_rw.get_fid()){
+          if (m_is_qf_to)
+            st = m_qf_to_rw.mk_eq_core(args[0], args[1], result);
+          else 
             st = m_a_rw.mk_eq_core(args[0], args[1], result);
+        }
         else if (s_fid == m_bv_rw.get_fid())
           st = m_bv_rw.mk_eq_core(args[0], args[1], result);
         else if (s_fid == m_dt_rw.get_fid())
@@ -203,8 +209,12 @@ struct th_rewriter_cfg : public default_rewriter_cfg {
       }
       return m_b_rw.mk_app_core(f, num, args, result);
     }
-        if (fid == m_a_rw.get_fid())
+    if (fid == m_a_rw.get_fid()){
+      if(m_is_qf_to)
+        return m_qf_to_rw.mk_app_core(f, num, args, result);
+      else
         return m_a_rw.mk_app_core(f, num, args, result);
+    }
     if (fid == m_bv_rw.get_fid())
       return m_bv_rw.mk_app_core(f, num, args, result);
     if (fid == m_ar_rw.get_fid())
@@ -667,9 +677,10 @@ struct th_rewriter_cfg : public default_rewriter_cfg {
     return true;
   }
 
-    th_rewriter_cfg(ast_manager & m, params_ref const & p):
+  th_rewriter_cfg(ast_manager & m, params_ref const & p, bool is_qf_to):
     m_b_rw(m, p),
     m_a_rw(m, p),
+    m_qf_to_rw(m, p),
     m_bv_rw(m, p),
     m_ar_rw(m, p),
     m_dt_rw(m),
@@ -681,6 +692,7 @@ struct th_rewriter_cfg : public default_rewriter_cfg {
     m_bv_util(m),
     m_used_dependencies(m),
     m_subst(nullptr) {
+      m_is_qf_to = is_qf_to;
       updt_local_params(p);
     }
 
@@ -703,17 +715,15 @@ struct th_rewriter_cfg : public default_rewriter_cfg {
     }
     return false;
   }
-
-
 };
 
 template class rewriter_tpl<th_rewriter_cfg>;
 
 struct th_rewriter::imp : public rewriter_tpl<th_rewriter_cfg> {
   th_rewriter_cfg m_cfg;
-    imp(ast_manager & m, params_ref const & p):
+  imp(ast_manager & m, params_ref const & p, bool is_qf_to):
     rewriter_tpl<th_rewriter_cfg>(m, m.proofs_enabled(), m_cfg),
-        m_cfg(m, p) {
+    m_cfg(m, p, is_qf_to) {
     }
   expr_ref mk_app(func_decl* f, unsigned sz, expr* const* args) {
     return m_cfg.mk_app(f, sz, args);
@@ -724,9 +734,9 @@ struct th_rewriter::imp : public rewriter_tpl<th_rewriter_cfg> {
   }
 };
 
-th_rewriter::th_rewriter(ast_manager & m, params_ref const & p):
-    m_params(p) {
-    m_imp = alloc(imp, m, p);
+th_rewriter::th_rewriter(ast_manager & m, params_ref const & p, bool is_qf_to):
+  m_params(p), m_is_qf_to(is_qf_to) {
+    m_imp = alloc(imp, m, p, is_qf_to);
   }
 
 ast_manager & th_rewriter::m() const {
@@ -762,7 +772,7 @@ unsigned th_rewriter::get_num_steps() const {
 void th_rewriter::cleanup() {
   ast_manager & m = m_imp->m();
   dealloc(m_imp);
-    m_imp = alloc(imp, m, m_params);
+  m_imp = alloc(imp, m, m_params, m_is_qf_to);
 }
 
 void th_rewriter::reset() {
diff --git a/src/ast/rewriter/th_rewriter.h b/src/ast/rewriter/th_rewriter.h
index db495e8da..697be755b 100644
--- a/src/ast/rewriter/th_rewriter.h
+++ b/src/ast/rewriter/th_rewriter.h
@@ -30,9 +30,10 @@ class expr_solver;
 class th_rewriter {
   struct imp;
   imp *  m_imp;
+  bool   m_is_qf_to;
   params_ref m_params;
   public:
-    th_rewriter(ast_manager & m, params_ref const & p = params_ref());
+  th_rewriter(ast_manager & m, params_ref const & p = params_ref(), bool is_qf_to = false);
   ~th_rewriter();
 
   ast_manager & m () const;
iff --git a/src/util/max_cliques.h b/src/util/max_cliques.h
index 0bf67592c..340d3fee7 100644
--- a/src/util/max_cliques.h
+++ b/src/util/max_cliques.h
@@ -128,15 +128,10 @@ public:
                 turn = !turn;
             }
             if (clique.size() > 1) {
-                if (clique.size() == 2 && clique[0] == negate(clique[1])) {
-                    // no op
-                }
-                else {
                 cliques.push_back(clique);
             }
         }
     }
-    }
 
 
 };
diff --git a/src/tactic/arith/purify_arith_tactic.cpp b/src/tactic/arith/purify_arith_tactic.cpp
index 67dadd34b..0774c036d 100644
--- a/src/tactic/arith/purify_arith_tactic.cpp
+++ b/src/tactic/arith/purify_arith_tactic.cpp
@@ -27,7 +27,8 @@ Revision History:
 #include "tactic/core/nnf_tactic.h"
 #include "tactic/core/simplify_tactic.h"
 #include "ast/rewriter/th_rewriter.h"
-#include "tactic/generic_model_converter.h"
+#include "tactic/filter_model_converter.h"
+#include "tactic/extension_model_converter.h"
 #include "ast/ast_smt2_pp.h"
 #include "ast/rewriter/expr_replacer.h"
 
@@ -763,23 +764,25 @@ struct purify_arith_proc {
             m_goal.assert_expr(r.cfg().m_new_cnstrs.get(i), m_produce_proofs ? r.cfg().m_new_cnstr_prs.get(i) : nullptr, nullptr);
         }
         
-        // add generic_model_converter to eliminate auxiliary variables from model
+        // add filter_model_converter to eliminate auxiliary variables from model
         if (produce_models) {
-            generic_model_converter * fmc = alloc(generic_model_converter, m(), "purify");
+            filter_model_converter * fmc = alloc(filter_model_converter, m());
             mc = fmc;
             obj_map<app, expr*> & f2v = r.cfg().m_app2fresh;
-            for (auto const& kv : f2v) {
-                app * v = to_app(kv.m_value);
+            obj_map<app, expr*>::iterator it  = f2v.begin();
+            obj_map<app, expr*>::iterator end = f2v.end();
+            for (; it != end; ++it) {
+                app * v = to_app(it->m_value);
                 SASSERT(is_uninterp_const(v));
-                fmc->hide(v->get_decl());
+                fmc->insert(v->get_decl());
             }
         }
         if (produce_models && !m_sin_cos.empty()) {
-            generic_model_converter* emc = alloc(generic_model_converter, m(), "purify_sin_cos");
+            extension_model_converter* emc = alloc(extension_model_converter, m());
             mc = concat(mc.get(), emc);
             obj_map<app, std::pair<expr*,expr*> >::iterator it = m_sin_cos.begin(), end = m_sin_cos.end();
             for (; it != end; ++it) {
-                emc->add(it->m_key->get_decl(), 
+                emc->insert(it->m_key->get_decl(), 
                             m().mk_ite(u().mk_ge(it->m_value.first, mk_real_zero()), u().mk_acos(it->m_value.second), 
                                        u().mk_add(u().mk_acos(u().mk_uminus(it->m_value.second)), u().mk_pi())));
             }
@@ -821,9 +824,13 @@ public:
     }
     
     void operator()(goal_ref const & g,
-                    goal_ref_buffer & result) override {
+                    goal_ref_buffer & result,
+                    model_converter_ref & mc,
+                    proof_converter_ref & pc,
+                    expr_dependency_ref & core) override {
         try {
             SASSERT(g->is_well_sorted());
+            mc = nullptr; pc = nullptr; core = nullptr;
             tactic_report report("purify-arith", *g);
             TRACE("purify_arith", g->display(tout););
             bool produce_proofs = g->proofs_enabled();
@@ -832,9 +839,9 @@ public:
             bool elim_inverses  = m_params.get_bool("elim_inverses", true);
             bool complete       = m_params.get_bool("complete", true);
             purify_arith_proc proc(*(g.get()), m_util, produce_proofs, elim_root_objs, elim_inverses, complete);
-            model_converter_ref mc;
+            
             proc(mc, produce_models);
-            g->add(mc.get());
+            
             g->inc_depth();
             result.push_back(g.get());
             TRACE("purify_arith", g->display(tout););
